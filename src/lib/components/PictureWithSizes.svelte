<script lang="ts">
	// AVIF/WEBP + JPG(640) responsive picture
	// gets sizes from meta data created by image pipeline scripts/process-images.mjs
	// adjust settings per mime type ... also adjust sizes but must match pipeline
	// This is the best one to use for static projects as it gets the width and height sizes
	/* example usage for grid layout to make sure it does not pick large image

		<Picture
						src={podcast.thumb}
						alt={podcast.title}
						loading={i === 0 ? 'eager' : 'lazy'}
						fetchPriority={i === 0 ? 'high' : 'auto'}
						sizes="(min-width: 1200px) 25vw, (min-width: 768px) 33vw, 100vw"
						maxWidth={640}
						class="card-image"
					></Picture>




	<script lang="ts">
	// AVIF/WEBP + JPG(640) responsive picture
If the viewport is 1200px wide or more,
the image takes up roughly 25% of the viewport width.

In your grid, this corresponds to the desktop layout
where four cards fit across the page → each card ≈ 25% width            

If you want to adopt the old Storynory pattern, I’d do:

// in your image script
const SIZES = [400, 640, 960];


and in Picture.svelte:

const ALL_WIDTHS = [400, 640, 960] as const;


Then keep using maxWidth={640} for card layouts so mobile never goes above 640, and reserve 960 for the odd hero/banner.


   */

	let {
		src = '',
		alt = '',
		loading = 'lazy',
		fetchPriority = 'auto',
		class: className = '',
		sizes,
		maxWidth = 960
	} = $props<{
		src?: string;
		alt?: string;
		loading?: 'lazy' | 'eager';
		fetchPriority?: 'high' | 'low' | 'auto';
		class?: string;
		sizes?: string;
		maxWidth?: number; // e.g. 640 for cards, 960 for hero
	}>();

	// Import intrinsic sizes generated by the Node script
	// (file written to src/lib/image-sizes.json)
	// eslint-disable-next-line @typescript-eslint/ban-ts-comment
	// @ts-ignore
	import imageMeta from '$lib/image-sizes.json';

	type ImageMeta = Record<string, { width: number | null; height: number | null }>;

	const metaMap = imageMeta as ImageMeta;

	// Find metadata by the original src (e.g. "/uploads/memes/foo.jpg")
	const meta = metaMap[src] ?? null;

	const intrinsicWidth = meta?.width ?? 640;
	const intrinsicHeight = meta?.height ?? 360;

	// Strip extension: /uploads/foo.jpg → /uploads/foo
	const base = src.replace(/\.[^.]+$/, '');

	// All generated widths from your image script
	const ALL_WIDTHS = [320, 640, 960] as const;

	// Filter by maxWidth so you can reuse the component everywhere
	const widths = ALL_WIDTHS.filter((w) => w <= maxWidth && w <= intrinsicWidth);

	// Safety net: if someone passed maxWidth < 320, fall back to smallest
	const effectiveWidths = widths.length > 0 ? widths : [ALL_WIDTHS[0]];

	const avifSrcset = effectiveWidths.map((w) => `${base}.${w}.avif ${w}w`).join(', ');

	const webpSrcset = effectiveWidths.map((w) => `${base}.${w}.webp ${w}w`).join(', ');

	// Fallback JPG (only 640 exists from your script)
	const jpgFallback = `${base}.640.jpg`;

	// Safe default; you can override with `sizes` prop
	const defaultSizes = '(min-width: 1200px) 25vw, (min-width: 768px) 33vw, 100vw';
</script>

<picture class={className}>
	<!--	<source
		srcset={avifSrcset}
		sizes={sizes ?? defaultSizes}
		type="image/avif"
	>  -->
	<source srcset={webpSrcset} sizes={sizes ?? defaultSizes} type="image/webp" />
	<img
		src={jpgFallback}
		{alt}
		loading={loading ?? undefined}
		fetchpriority={fetchPriority}
		decoding="async"
		width={intrinsicWidth}
		height={intrinsicHeight}
		sizes={sizes ?? defaultSizes}
	/>
</picture>

<style>
	img {
		display: block;
		width: 100%;
		height: auto;
	}
</style>
